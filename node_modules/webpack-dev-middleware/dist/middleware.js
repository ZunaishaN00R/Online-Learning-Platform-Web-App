"use strict";

const path = require("path");

const mime = require("mime-types");

const parseRange = require("range-parser");

const getFilenameFromUrl = require("./utils/getFilenameFromUrl");

const {
  getHeaderNames,
  getHeaderFromRequest,
  getHeaderFromResponse,
  setHeaderForResponse,
  setStatusCode,
  send
} = require("./utils/compatibleAPI");

const ready = require("./utils/ready");
/** @typedef {import("./index.js").NextFunction} NextFunction */

/** @typedef {import("./index.js").IncomingMessage} IncomingMessage */

/** @typedef {import("./index.js").ServerResponse} ServerResponse */

/**
 * @param {string} type
 * @param {number} size
 * @param {import("range-parser").Range} [range]
 * @returns {string}
 */


function getValueContentRangeHeader(type, size, range) {
  return `${type} ${range ? `${range.start}-${range.end}` : "*"}/${size}`;
}
/**
 * @param {string | number} title
 * @param {string} body
 * @returns {string}
 */


function createHtmlDocument(title, body) {
  return `${"<!DOCTYPE html>\n" + '<html lang="en">\n' + "<head>\n" + '<meta charset="utf-8">\n' + "<title>"}${title}</title>\n` + `</head>\n` + `<body>\n` + `<pre>${body}</pre>\n` + `</body>\n` + `</html>\n`;
}

const BYTES_RANGE_REGEXP = /^ *bytes/i;
/**
 * @template {IncomingMessage} Request
 * @template {ServerResponse} Response
 * @param {import("./index.js").Context<Request, Response>} context
 * @return {import("./index.js").Middleware<Request, Response>}
 */

function wrapper(context) {
  return async function middleware(req, res, next) {
    const acceptedMethods = context.options.methods || ["GET", "HEAD"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.
    // eslint-disable-next-line no-param-reassign

    res.locals = res.locals || {};

    if (req.method && !acceptedMethods.includes(req.method)) {
      await goNext();
      return;
    }

    ready(context, processRequest, req);

    async function goNext() {
      if (!context.options.serverSideRender) {
        return next();
      }

      return new Promise(resolve => {
        ready(context, () => {
          /** @type {any} */
          // eslint-disable-next-line no-param-reassign
          res.locals.webpack = {
            devMiddleware: context
          };
          resolve(next());
        }, req);
      });
    }

    async function processRequest() {
      const filename = getFilenameFromUrl(context,
      /** @type {string} */
      req.url);

      if (!filename) {
        await goNext();
        return;
      }

      let {
        headers
      } = context.options;

      if (typeof headers === "function") {
        // @ts-ignore
        headers = headers(req, res, context);
      }
      /**
       * @type {{key: string, value: string | number}[]}
       */


      const allHeaders = [];

      if (typeof headers !== "undefined") {
        if (!Array.isArray(headers)) {
          // eslint-disable-next-line guard-for-in
          for (const name in headers) {
            // @ts-ignore
            allHeaders.push({
              key: name,
              value: 